filter {
  grok {
    patterns_dir => ["/opt/logstash/extra_patterns"]
    match => { "message" => "%{TIMESTAMP_JP:read_timestamp}" }
  }

  date {
    match => ["read_timestamp", "yyyy/MM/dd,HH:mm:ss"]
    timezone => "Asia/Tokyo"
    target => "@timestamp"
  }

  grok {
    match => { "message" => "Result,%{WORD:Result}" }
  }

  # split{}

  mutate {
    copy => { "message" => "messages" }
  }

  mutate {
    gsub => ["messages", "\n", "::"]
  }
  mutate {
    split => { "messages" => "::" }
  }

   ruby { code => '
        mess = event.get("messages")
        a = []
        mess.each do |message|
          items = message.split(",")
          h = { "Step" => items[0], "TestName" => items[1], "Value1" => items[2], "Judge" => items[3] }
          a << h
        end
        event.set("arrayOfHashes", a)
   '
   }
  # csv {
  #   columns => ["Step","TestName","Value1","Judge"]
  #   separator => ","
  # }
  # mutate {
  #   rename => { "Step" => "[Test][Steps]" }
  # }
  # ruby {
  #   code => 'event.set("test",event.get("Step"))'
  # }

  # if [Step] == "Step" {
  #   aggregate {
  #     task_id => "%{read_timestamp}"
  #     code => "map[%{Step}] ||= 0 ; map[%{Step}] = %{message}"
  #   }
  # }

  # if [Step] == "End" {
  #   aggregate {
  #     task_id => "%{read_timestamp}"
  #     code => "map[%{Step}] ||= 0 ; map[%{Step}] = %{message}"
  #     end_of_task => true
  #   }
  # }
  # if [Step] !~ /\d+/ {
  #   drop{}
  # }

  # mutate {
  #   convert => {
  #     "Step" => "integer"
  #     "Value1" => "float"
  #   }
  # }

  fingerprint {
    source => "message"
    target => "[@metadata][fingerprint]"
    method => "MD5"
    key => "test"
  }
  
  ruby { code => 'event.set("[@metadata][prefix]", event.get("@timestamp").to_i.to_s(16))' }

  # mutate {
  #   remove_field => ["read_timestamp", "message"]
  # }
}
