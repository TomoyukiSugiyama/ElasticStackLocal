filter {
  grok {
    patterns_dir => ["/opt/logstash/extra_patterns"]
    match => { "message" => "%{TIMESTAMP_JP:read_timestamp}" }
  }

  date {
    match => ["read_timestamp", "yyyy/MM/dd,HH:mm:ss"]
    timezone => "Asia/Tokyo"
    target => "@timestamp"
  }

  grok {
    match => { "message" => "Result,%{WORD:Result}" }
  }

  # split{}

  # mutate {
  #   copy => { "message" => "messages" }
  # }

  # mutate {
  #   gsub => ["messages", "\n", "::"]
  # }
  # mutate {
  #   split => { "messages" => "::" }
  # }

  # ruby { code => '
  #   messages = event.get("messages")
  #   messageArrayOfNestedHash = []
  #   messages.each do |message|
  #     items = message.split(",")
  #     if items[0] !~ /\d+/
  #       next
  #     end
  #     itemsHash = { "Step" => items[0], "TestName" => items[1], "Value1" => items[2], "Judge" => items[3] }
  #     messageArrayOfNestedHash << itemsHash
  #   end
  #   event.set("messageArray", messageArrayOfNestedHash)
  # '
  # }

  ruby {
    code => '
      message = event.get("message")
      lines = message.split("\n")
      lines.each do |line|
        items = line.split(",")
        if items[0] !~ /\d+/
          next
        end
        itemsHash = { "Step" => items[0], "TstName" => items[1], "LoLimit" => items[2], "Data" => items[3] , "UpLimit" => items[4] , "Unit" => items[5] , "Judge" => items[6] }
        event.set("[data][#{items[0]}]", itemsHash)
      end
    '
  }
# event.set([items][#{items[0]}], itemsHash)
  # csv {
  #   columns => ["Step","TstName","LoLimit","Data","UpLimit","Unit","Judge"]
  #   separator => ","
  # }

  # if [Step] == "END" {

  # }else if [Step] !~ /\d+/{
  #   drop{}
  # }

  # mutate {
  #   copy => { 
  #     "LoLimit" => "LoLimitInt"
  #     "Data" => "DataInt"
  #     "UpLimit" => "UpLimitInt"
  #   }
  # }

  # if [Unit] == "HEX" {
  #   ruby {
  #       code => '
  #         event.set("LoLimitInt", event.get("LoLimit").to_i(16))
  #         event.set("DataInt", event.get("Data").to_i(16))
  #         event.set("UpLimitInt", event.get("UpLimit").to_i(16))
  #       '
  #   }
  # }else{
  #   mutate {
  #     convert => {
  #       # "Step" => "integer"
  #       "LoLimitInt" => "float"
  #       "DataInt" => "float"
  #       "UpLimitInt" => "float"
  #     }
  #   }
  # }

  fingerprint {
    source => "message"
    target => "[@metadata][fingerprint]"
    method => "MD5"
    key => "test"
  }
  
  ruby { code => 'event.set("[@metadata][prefix]", event.get("@timestamp").to_i.to_s(16))' }

  # mutate {
  #   remove_field => ["read_timestamp", "message"]
  # }
}
